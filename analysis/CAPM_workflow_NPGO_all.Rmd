---
title: "Workflow: Capital Asset Pricing Model for Ecological Portfolios"
output:
  html_document:
    fig_caption: yes
    theme: cerulean
    toc: yes
    toc_depth: 3
    toc_float: yes
    number_sections: true
---

```{r set_options, echo=FALSE, cache=FALSE}
options(width = 100)
```

***

[__Mark D. Scheuerell__](https://faculty.washington.edu/scheuerl/)  
_Fish Ecology Division, Northwest Fisheries Science Center, National Marine Fisheries Service, National Oceanic and Atmospheric Administration, Seattle, WA USA, <mark.scheuerell@noaa.gov>_

### Version

This is version `r paste0('0.',format(Sys.time(), '%y.%m.%d'))`.

***

# Initialization

```{r load_pkgs, message=FALSE}
library(readr)
library(reshape2)
library(MARSS)
```

# Data

For these analyses we will use time series of counts of adult spring/summer Chinook salmon from the Snake River basin in Oregon and Idaho. This group of fish forms an Evolutionarily Significant Unit, which was listed as threatened under the US Endangered Species Act in 1992.

The data were compiled largely through the efforts of Tom Cooney (Northwest Fisheries Science Center, National Marine Fisheries Service, National Oceanic and Atmospheric Administration, Portland, OR USA, <tom.cooney@noaa.gov>).

## Assets

The assets data file has the following columns of information:

* `pop` = abbreviated name of the population
* `code` = 5-letter abbreviation for MPG (2 letters) & population (3 letters)
* `mpg` = name of 1 of 5 Major Population Groups
* `ha` = estimated area (hectares) of available spawning habitat
* `category` = hatchery supplementation category ("impact" or "control")
* `brood_yr` = year when spawning occurred  
* `nS` = total number of spawning fish
* `phos` = proportion of hatchery-origin spawners

```{r read_data, collapse=TRUE}
rawdata <- read.csv("https://raw.githubusercontent.com/mdscheuerell/CAPM/master/data/srss_chin.csv")
head(rawdata)
```

The first thing to do is remove hatchery-origin spawners from the counts, and then convert the counts to log-density based on the estimated spawning area for each population. In a couple of years, incomplete censuses with small sample sizes led to estimated fractions of wild fish equal to zero. I will treat those as NA.

```{r get_wild_density}
dat <- rawdata[,c("mpg", "code", "pop", "category", "brood_yr")]
## calculate log-density
dat$Sw <- round(log(rawdata$nS*(1-rawdata$phos)/rawdata$ha), 2)
## replace possible -Inf with NA
dat$Sw[is.infinite(dat$Sw)] <- NA
```

For easier bookkeeping, I'll also switch the Imnaha's MPG over to the Grande Ronde.

```{r mpg_change}
## change Imnaha name for easier sorting later
dat[,"code"] <- sub("IRMAI", "GR_IR", dat[,"code"], fixed=TRUE)
## MPG abbreviations
mpg_ID <- c("GR", "MF", "SF", "SR")
```

Only a few of the populations have observations going all the way back to the 1950s, so I'll trim the data accordingly.

```{r, trim_years}
## use generation time of 4 years
gt <- 4
## first brood year to consider
yr_first <- 1960
## last brood year to consider
yr_last <- 2011
## years of interest
t_index <- seq(yr_first, yr_last-gt)
## length of time period
TT <- length(t_index)
## subset data
dat <- subset(dat, brood_yr>=yr_first & brood_yr<=yr_last)
```

I will use the `MARSS` package to fit the CAPM model, which requires the data to be formatted as an [N x T] matrix.

```{r get_assets}
## reshape assets
assets <- dcast(dat, brood_yr ~ code, value.var="Sw")[,-1]
## compute differences
assets <- t(apply(assets, 2, diff, lag=gt))
matplot(t(assets), type="b")
## number of popns
NN <- dim(assets)[1]
## names of popns
names_pop <- rownames(assets)
```

Finally, here are some nicer, longer names for the various populations.

```{r set_names}
# set up naming & ordering scheme
longnames <- c(
  "Wenaha",
  "Grande Ronde",
  "Catherine",
  "Minam",
  "Lostine",
  "Imnaha",
  "SF Salmon",
  "Secesh",
  "EFSF Salmon",
  "Big",
  "Sulphur",
  "Bear Valley",
  "Marsh",
  "Loon",
  "Camas",
  "Yankee Fork",
  "Valley",
  "UM Salmon",
  "LM Salmon",
  "EF Salmon",
  "Lemhi")
name_ord <- c(6,3,5,4,2,1,12,10,15,14,13,11,9,7,8,20,21,19,18,17,16)
names_mat <- data.frame(ord=name_ord, ID=names_pop)
names_mat <- names_mat[order(names_mat$ord),]
names_mat$long <- longnames
```

## Market index

The first "market"" index is based on the monthly North Pacific Gyre Oscillation (NPGO) data provided by Emanuele Di Lorenzo, which are available [here](http://www.o3d.org/npgo/npgo.php). We begin by downloading the raw NPGO data and viewing the metadata.

```{r get_NPGO_metadata}
## URL for NPGO data
url_NPGO <- "http://www.o3d.org/npgo/npgo.php"
## raw NPGO data 
all_NPGO <- read_lines(url_NPGO)
## line with data headers
hdr_NPGO <- which(lapply(all_NPGO,grep,pattern="YEAR")==1, arr.ind=TRUE)
## print PDO metadata
print(all_NPGO[seq(hdr_NPGO)],quote=FALSE)
```

Next, we will extract the actual NPGO indices for the years of interest and inspect the file contents. We also want the average annual NPGO index from January 1 through December 31 during the first year that the juvenile salmon are in the ocean (i.e., during their second year of life). Therefore, we need NPGO values from `yr_first + 2` = `r yr_first + 2` through `yr_last + 2` = `r yr_last + 2`.

```{r get_NPGO, message=FALSE, results='hold'}
## NPGO data for years of interest
raw_NPGO <- read_table(url_NPGO, col_names = FALSE, skip=hdr_NPGO + (yr_first+2-1950)*12, n_max = TT*12)
colnames(raw_NPGO) <- c("year","month","NPGO")
## calculate annual means
dat_NPGO <- aggregate(raw_NPGO$NPGO, by = list(year = raw_NPGO$year), FUN = mean)
colnames(dat_NPGO) <- c("brood_yr", "NPGO")
## match calendar yr to brood year
dat_NPGO$brood_yr <- dat_NPGO$brood_yr - 2
dat_NPGO
## market index
market <- round(dat_NPGO$NPGO, 3)
plot.ts(market)
cor(market, t(assets), use="pairwise.complete.obs")
```

## Risk-free index

For these purposes, the risk free index is zero for all years. The idea is that any population with a standardized return of zero is replacing itself and therefore not declining.

```{r risk_free}
free <- rep(0, TT)
```

# CAPM in MARSS

## a diag & unequal; b diag & unequal

```{r CAPM_v4, cache=TRUE}
## number of regr params = level + slope
mm <- 2

## number of assets
nn <- NN

## Process eqn
## B is Identity
BB <- "identity"
## U is col vec of 0's
UU <- "zero"
## Q will be block diagonal
QQ <- matrix(list(0),mm*nn,mm*nn)
## upper L block for alpha
aa <- 1:nn
## equal var-cov
# QQ[aa,aa] <- "alpha.cov"
# diag(QQ[aa,aa]) <- "alpha.var"
## diagonal & unequal
diag(QQ[aa,aa]) <- paste0("alpha",seq(nn))
## lower R block for beta
bb <- aa + nn
## diagonal & unequal
diag(QQ[bb,bb]) <- paste0("beta",seq(nn))

## Observation eqn
## Z is array of regr variables (ie, 1's and market returns)
ZZ <- array(NA, c(nn,mm*nn,TT))
for(t in 1:TT) {
  ZZ[,,t] <- cbind(1,market[t]) %x% diag(nn)
}
## A is col vec of 0's
AA <- "zero"
## assume same obs var & cov
##RR <- matrix(list(0),nn,nn)
##RR[aa,aa] <- "obs.cov"
##diag(RR[aa,aa]) <- "obs.var"
RR <- "diagonal and equal"

## Initial states
##x0 <- rbind(matrix("pi.a",nn,1), matrix("pi.b",nn,1))
##V0 <- 100*diag(mm*nn)
##x0 <- rbind(matrix(0,nn,1), matrix(1,nn,1))
##V0 <- matrix(list(0),mm*nn,mm*nn)
##diag(V0[aa,aa]) <- "var.a"
##diag(V0[bb,bb]) <- "var.b"

## starting values for regr parameters
ini_list <- list(x0=matrix(1, mm*nn, 1))

## list of model matrices & vectors
mod_list <- list(B=BB, U=UU, Q=QQ, Z=ZZ, A=AA, R=RR)
##mod_list <- list(B=BB, U=UU, Q=QQ, Z=ZZ, A=AA, R=RR, x0=x0, V0=V0)

## list of control values
con_list <- list(safe=TRUE, allow.degen=FALSE,
                 conv.test.slope.tol=2, abstol=1e-04, maxit=5e04)

## fit multivariate DLM
mod_res <- MARSS(assets, inits=ini_list, model=mod_list, control=con_list)

## get list of Kalman filter output
kf_out <- MARSSkfss(mod_res)

## ts of forecasted betas
betas4 <- t(kf_out$xtt1[(1:nn)+nn,])

## ts of SE of betas; nxT matrix
betas4_se <- sqrt(t(apply(kf_out$Vtt1,3,diag)[(1:nn)+nn,]))

## ts of alphas
alphas <- t(mod_res$states[1:nn,])
## ts of SE{alphas}
alphas_se <- t(mod_res$states.se[1:nn,])

## ts of betas
betas <- t(mod_res$states[(1:nn)+nn,])
## ts of SE{betas}
betas_se <- t(mod_res$states.se[(1:nn)+nn,])

## assign names
colnames(alphas) <- colnames(alphas_se) <- names_pop
colnames(betas) <- colnames(betas_se) <- names_pop
colnames(betas4) <- colnames(betas4_se) <- names_pop
```

### Plots of results

```{r plot_betas, fig.height=5, fig.width=9}
betas <- betas[,names_mat$ID]

# total num of ts
NN <- dim(betas)[2]

# set up colors; group by MPG
col.pal <- c(rainbow(6, start=0.05, end=0.12),
			 rainbow(3, start=0.2, end=0.45, v=0.7),
			 rainbow(6, start=0.8, end=0.95, v=0.85),
			 rainbow(6, start=0.55, end=0.7))

# num of rows for plot
nr <- 3
# num of cols for plot
nc <- 7

# set graphics params
par(mfcol=c(nr,nc), mai=c(0.1,0.07,0.2,0.07), omi=c(0.6,0.6,0,0))

# get extent of y-limits
yext <- c(floor(min(betas-2*betas_se, na.rm=T)/0.5)*0.5,
          ceiling(max(betas+2*betas_se, na.rm=T)/0.5)*0.5)
yext <- c(floor(min(betas-2*betas_se, na.rm=T)/0.1)*0.1,
          ceiling(max(betas+2*betas_se, na.rm=T)/0.1)*0.1)

# draw plots
for(i in 1:NN) {
	plot(t_index, betas[,i], type="n",
		 ylim=yext, xaxt="n", yaxt="n",
		 xlab="", ylab="", main=names_mat[i,"long"])
	rect(par()$usr[1], -1, par()$usr[2], 1, col=gray(0.9), border=gray(0.9))
	abline(h=0, lty="dashed")
	box()
	lines(t_index, betas[,i], col=col.pal[i], lwd=2.2)
	lines(t_index, betas[,i]+2*betas_se[,i], col=col.pal[i], lwd=0.7)
	lines(t_index, betas[,i]-2*betas_se[,i], col=col.pal[i], lwd=0.7)
	#text(xin, yin, names.pop[i], adj=c(0,1))	
	if(i<=nr | nc==1) {
#		axis(side=2, at=seq(ceiling(yext[1]/2)*2,floor(yext[2]/2)*2), las=1)
#		axis(side=2, at=seq(yext[1],yext[2])[(seq(yext[1],yext[2])%%1)==0])
		axis(side=2, las=1, tick=TRUE)
		}
	if(i%%nr==0) {
		axis(side=1, at=t_index[(t_index %% 10)==0])
		}
	}
#mtext("Brood year", side=1, outer=TRUE, line=3, cex=1.2)
mtext("Year", side=1, outer=TRUE, line=3, cex=1.2)
mtext(expression(beta[italic(t)]), side=2, outer=TRUE, line=2.2, cex=1.5)
```

