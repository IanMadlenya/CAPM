---
title: "Workflow: Capital Asset Pricing Model for Ecological Portfolios"
output:
  html_document:
    fig_caption: yes
    theme: cerulean
    toc: yes
    toc_depth: 3
    toc_float: yes
    number_sections: true
---

```{r set_options, echo=FALSE, cache=FALSE}
options(width = 100)
```

***

[__Mark D. Scheuerell__](https://faculty.washington.edu/scheuerl/)  
_Fish Ecology Division, Northwest Fisheries Science Center, National Marine Fisheries Service, National Oceanic and Atmospheric Administration, Seattle, WA USA, <mark.scheuerell@noaa.gov>_

### Version

This is version `r paste0('0.',format(Sys.time(), '%y.%m.%d'))`.

***

# Initialization

```{r load_pkgs, message=FALSE}
library(readr)
library(reshape2)
library(MARSS)
```

# Data

For these analyses we will use time series of counts of adult spring/summer Chinook salmon from the Snake River basin in Oregon and Idaho. This group of fish forms an Evolutionarily Significant Unit, which was listed as threatened under the US Endangered Species Act in 1992.

The data were compiled largely through the efforts of Tom Cooney (Northwest Fisheries Science Center, National Marine Fisheries Service, National Oceanic and Atmospheric Administration, Portland, OR USA, <tom.cooney@noaa.gov>).

## Assets

The assets data file has the following columns of information:

* `pop` = abbreviated name of the population
* `code` = 5-letter abbreviation for MPG (2 letters) & population (3 letters)
* `mpg` = name of 1 of 5 Major Population Groups
* `ha` = estimated area (hectares) of available spawning habitat
* `category` = hatchery supplementation category ("impact" or "control")
* `brood_yr` = year when spawning occurred  
* `nS` = total number of spawning fish
* `phos` = proportion of hatchery-origin spawners

```{r read_data, collapse=TRUE}
rawdata <- read.csv("https://raw.githubusercontent.com/mdscheuerell/CAPM/master/data/srss_chin.csv")
head(rawdata)
```

The first thing to do is remove hatchery-origin spawners from the counts, and then convert the counts to log-density based on the estimated spawning area for each population. In a couple of years, incomplete censuses with small sample sizes led to estimated fractions of wild fish equal to zero. I will treat those as NA.

```{r get_wild_density}
dat <- rawdata[,c("mpg", "code", "pop", "category", "brood_yr")]
## calculate log-density
dat$Sw <- round(log(rawdata$nS*(1-rawdata$phos)/rawdata$ha), 2)
## replace possible -Inf with NA
dat$Sw[is.infinite(dat$Sw)] <- NA
```

For easier bookkeeping, I'll also switch the Imnaha's MPG over to the Grande Ronde.

```{r mpg_change}
## change Imnaha name for easier sorting later
dat[,"code"] <- sub("IRMAI", "GR_IR", dat[,"code"], fixed=TRUE)
## MPG abbreviations
mpg_ID <- c("GR", "MF", "SF", "SR")
```

Only a few of the populations have observations going all the way back to the 1950s, so I'll trim the data accordingly.

```{r, trim_years}
## use generation time of 4 years
gt <- 4
## first brood year to consider
yr_first <- 1960
## last brood year to consider
yr_last <- 2011
## years of interest
t_index <- seq(yr_first, yr_last-gt)
## length of time period
TT <- length(t_index)
## subset data
dat <- subset(dat, brood_yr>=yr_first & brood_yr<=yr_last)
```

I will use the `MARSS` package to fit the CAPM model, which requires the data to be formatted as an [N x T] matrix.

```{r get_assets}
## reshape assets
assets <- dcast(dat, brood_yr ~ code, value.var="Sw")[,-1]
## compute differences
assets <- t(apply(assets, 2, diff, lag=gt))
matplot(t(assets), type="b")
## number of popns
NN <- dim(assets)[1]
## names of popns
names_pop <- rownames(assets)
```

Finally, here are some nicer, longer names for the various populations.

```{r set_names}
# set up naming & ordering scheme
longnames <- c(
  "Wenaha",
  "Grande Ronde",
  "Catherine",
  "Minam",
  "Lostine",
  "Imnaha",
  "SF Salmon",
  "Secesh",
  "EFSF Salmon",
  "Big",
  "Sulphur",
  "Bear Valley",
  "Marsh",
  "Loon",
  "Camas",
  "Yankee Fork",
  "Valley",
  "UM Salmon",
  "LM Salmon",
  "EF Salmon",
  "Lemhi")
name_ord <- c(6,3,5,4,2,1,12,10,15,14,13,11,9,7,8,20,21,19,18,17,16)
names_mat <- data.frame(ord=name_ord, ID=names_pop)
names_mat <- names_mat[order(names_mat$ord),]
names_mat$long <- longnames
```

## Market index

We used the monthly PDO data provided by the University of Washington's Joint Institute for the Study of the Atmosphere and Ocean ([JISAO](http://jisao.washington.edu/)), which are available [here](http://research.jisao.washington.edu/pdo/). We begin by downloading the raw PDO data and viewing the metadata.

```{r get_PDO_metadata}
## raw PDO data from UW
PDO_raw <- readLines("http://research.jisao.washington.edu/pdo/PDO.latest")
## line with data headers
hdr_pdo <- which(lapply(PDO_raw,grep,pattern="YEAR")==1, arr.ind=TRUE)
## print PDO metadata
print(PDO_raw[seq(hdr_pdo-1)],quote=FALSE)
```

Next, we will extract the actual PDO indices for the years of interest and inspect the file contents.

```{r get_PDO}
## PDO data for years of interest
dat_PDO <- read.table("http://research.jisao.washington.edu/pdo/PDO.latest",
                      header=FALSE, stringsAsFactors=FALSE,
                      skip=hdr_pdo + yr_first - 1900 + 1 + 2, nrows=TT)
colnames(dat_PDO) <- unlist(strsplit(tolower(PDO_raw[hdr_pdo]), split="\\s+"))
dat_PDO
```

Notice that values in the year column in the PDO data file contains an ** superscript from 2002 onward to indicate the switch to version 2 of the sea surface temperature (SST) data. We will fix those as well.

```{r adj_PDO}
## fix 'year' col
dat_PDO$year <- seq(1:TT) + yr_first - 1
## mean PDO from Apr-Oct indexed by brood year
PDO_ts <- apply(dat_PDO[,-1],1,mean)
dat_PDO <- data.frame(year=dat_PDO$year, PDO=PDO_ts)
## market index
market <- round(dat_PDO$PDO, 3)
plot.ts(market)
```

## Risk-free index

For these purposes, the risk free index is zero for all years. The idea is that any population with a standardized return of zero is replacing itself and therefore not declining.

```{r risk_free}
free <- rep(0, TT)
```

# CAPM in MARSS

## v1: a static; b unconstrained

```{r CAPM_v1, cache=TRUE}
## empty list for model results
mod_res <- vector("list", length(mpg_ID))
## empty beta forecasts
betas4 <- betas4_se <- NULL
## empty alphas & betas
alphas <- alphas_se <- betas <- betas_se <- NULL

## number of regr params = level + slope
mm <- 2

## CAPMs for each MPG
for(i in 1:length(mpg_ID)) {
  
  ## print loop ID
  print(paste0("i = ",i,"; MPG = ",mpg_ID[i]))
  ## get popns
  assets_mpg <- assets[grep(mpg_ID[i], rownames(assets)),]
  ## number of assets
  nn <- dim(assets_mpg)[1]
  
  ## Process eqn
  ## B is Identity
  BB <- "identity"
  ## U is col vec of 0's
  UU <- "zero"
  ## Q will be block diagonal
  QQ <- matrix(list(0),mm*nn,mm*nn)
  ## upper L block for alpha
  aa <- 1:nn
  ## lower R block for beta
  bb <- aa + nn
  ## equal var-cov
  # QQ[bb,bb] <- "beta.cov"
  # diag(QQ[bb,bb]) <- "beta.var"
  ## diagonal & unequal
  diag(QQ[bb,bb]) <- paste0("beta",seq(nn))
  for(j in 1:(nn-1)) {
    for(k in (j+1):nn) {
      QQ[j+nn,k+nn] <- paste0("beta",j,k)
      QQ[k+nn,j+nn] <- paste0("beta",j,k)
    }
  }
  
  ## Observation eqn
  ## Z is array of regr variables (ie, 1's and market returns)
  ZZ <- array(NA, c(nn,mm*nn,TT))
  for(t in 1:TT) {
    ZZ[,,t] <- cbind(1,market[t]) %x% diag(nn)
  }
  ## A is col vec of 0's
  AA <- "zero"
  ## assume same obs var & cov
  ##RR <- matrix(list(0),nn,nn)
  ##RR[aa,aa] <- "obs.cov"
  ##diag(RR[aa,aa]) <- "obs.var"
  RR <- "diagonal and equal"
  
  ## Initial states
  ##x0 <- rbind(matrix("pi.a",nn,1), matrix("pi.b",nn,1))
  ##V0 <- 100*diag(mm*nn)
  ##x0 <- rbind(matrix(0,nn,1), matrix(1,nn,1))
  ##V0 <- matrix(list(0),mm*nn,mm*nn)
  ##diag(V0[aa,aa]) <- "var.a"
  ##diag(V0[bb,bb]) <- "var.b"
  
  ## starting values for regr parameters
  ini_list <- list(x0=matrix(1, mm*nn, 1))
  
  ## list of model matrices & vectors
  mod_list <- list(B=BB, U=UU, Q=QQ, Z=ZZ, A=AA, R=RR)
  ##mod_list <- list(B=BB, U=UU, Q=QQ, Z=ZZ, A=AA, R=RR, x0=x0, V0=V0)
  
  ## list of control values
  con_list <- list(safe=TRUE, allow.degen=FALSE,
                   conv.test.slope.tol=2, abstol=1e-04, maxit=5e04)
  
  ## fit multivariate DLM
  mod_res[[i]] <- MARSS(assets_mpg, inits=ini_list, model=mod_list, control=con_list)
  
  ## get list of Kalman filter output
  kf_out = MARSSkfss(mod_res[[i]])
  
  ## ts of forecasted betas
  betas4 <- cbind(betas4,t(kf_out$xtt1[(1:nn)+nn,]))
  
  ## ts of SE of betas; nxT matrix
  betas4_se <- cbind(betas4_se,sqrt(t(apply(kf_out$Vtt1,3,diag)[(1:nn)+nn,])))
  
  ## ts of alphas
  alphas <- cbind(alphas,t(mod_res[[i]]$states[1:nn,]))
  ## ts of SE{alphas}
  alphas_se <- cbind(alphas_se,t(mod_res[[i]]$states.se[1:nn,]))
  
  ## ts of betas
  betas <- cbind(betas,t(mod_res[[i]]$states[(1:nn)+nn,]))
  ## ts of SE{betas}
  betas_se <- cbind(betas_se,t(mod_res[[i]]$states.se[(1:nn)+nn,]))
  
}

## assign names
colnames(alphas) <- colnames(alphas_se) <- names_pop
colnames(betas) <- colnames(betas_se) <- names_pop
colnames(betas4) <- colnames(betas4_se) <- names_pop
```

### Plots of results

```{r plot_betas_v1_1, fig.height=5, fig.width=9}
betas <- betas[,names_mat$ID]

# total num of ts
NN <- dim(betas)[2]

# set up colors; group by MPG
col.pal <- c(rainbow(6, start=0.05, end=0.12),
			 rainbow(3, start=0.2, end=0.45, v=0.7),
			 rainbow(6, start=0.8, end=0.95, v=0.85),
			 rainbow(6, start=0.55, end=0.7))

# num of rows for plot
nr <- 3
# num of cols for plot
nc <- 7

# set graphics params
par(mfcol=c(nr,nc), mai=c(0.1,0.07,0.2,0.07), omi=c(0.6,0.6,0,0))

# get extent of y-limits
yext <- c(floor(min(betas-2*betas_se, na.rm=T)/0.5)*0.5,
          ceiling(max(betas+2*betas_se, na.rm=T)/0.5)*0.5)
yext <- c(floor(min(betas-2*betas_se, na.rm=T)/0.1)*0.1,
          ceiling(max(betas+2*betas_se, na.rm=T)/0.1)*0.1)

# draw plots
for(i in 1:NN) {
	plot(t_index, betas[,i], type="n",
		 ylim=yext, xaxt="n", yaxt="n",
		 xlab="", ylab="", main=names_mat[i,"long"])
	rect(par()$usr[1], -1, par()$usr[2], 1, col=gray(0.9), border=gray(0.9))
	abline(h=0, lty="dashed")
	box()
	lines(t_index, betas[,i], col=col.pal[i], lwd=2.2)
	lines(t_index, betas[,i]+2*betas_se[,i], col=col.pal[i], lwd=0.7)
	lines(t_index, betas[,i]-2*betas_se[,i], col=col.pal[i], lwd=0.7)
	#text(xin, yin, names.pop[i], adj=c(0,1))	
	if(i<=nr | nc==1) {
#		axis(side=2, at=seq(ceiling(yext[1]/2)*2,floor(yext[2]/2)*2), las=1)
#		axis(side=2, at=seq(yext[1],yext[2])[(seq(yext[1],yext[2])%%1)==0])
		axis(side=2, las=1, tick=TRUE)
		}
	if(i%%nr==0) {
		axis(side=1, at=t_index[(t_index %% 10)==0])
		}
	}
#mtext("Brood year", side=1, outer=TRUE, line=3, cex=1.2)
mtext("Year", side=1, outer=TRUE, line=3, cex=1.2)
mtext(expression(beta[italic(t)]), side=2, outer=TRUE, line=2.2, cex=1.5)
```

## v1: a static; b equalvarcov

```{r CAPM_v1_2, cache=TRUE}
## empty list for model results
mod_res <- vector("list", length(mpg_ID))
## empty beta forecasts
betas4 <- betas4_se <- NULL
## empty alphas & betas
alphas <- alphas_se <- betas <- betas_se <- NULL

## number of regr params = level + slope
mm <- 2

## CAPMs for each MPG
for(i in 1:length(mpg_ID)) {
  
  ## print loop ID
  print(paste0("i = ",i,"; MPG = ",mpg_ID[i]))
  ## get popns
  assets_mpg <- assets[grep(mpg_ID[i], rownames(assets)),]
  ## number of assets
  nn <- dim(assets_mpg)[1]
  
  ## Process eqn
  ## B is Identity
  BB <- "identity"
  ## U is col vec of 0's
  UU <- "zero"
  ## Q will be block diagonal
  QQ <- matrix(list(0),mm*nn,mm*nn)
  ## upper L block for alpha
  aa <- 1:nn
  ## lower R block for beta
  bb <- aa + nn
  ## equal var-cov
  # QQ[bb,bb] <- "beta.cov"
  # diag(QQ[bb,bb]) <- "beta.var"
  ## diagonal & unequal
  diag(QQ[bb,bb]) <- paste0("beta",seq(nn))
  for(j in 1:(nn-1)) {
    for(k in (j+1):nn) {
      QQ[j+nn,k+nn] <- paste0("beta",j,k)
      QQ[k+nn,j+nn] <- paste0("beta",j,k)
    }
  }
  
  ## Observation eqn
  ## Z is array of regr variables (ie, 1's and market returns)
  ZZ <- array(NA, c(nn,mm*nn,TT))
  for(t in 1:TT) {
    ZZ[,,t] <- cbind(1,market[t]) %x% diag(nn)
  }
  ## A is col vec of 0's
  AA <- "zero"
  ## assume same obs var & cov
  ##RR <- matrix(list(0),nn,nn)
  ##RR[aa,aa] <- "obs.cov"
  ##diag(RR[aa,aa]) <- "obs.var"
  RR <- "diagonal and equal"
  
  ## Initial states
  ##x0 <- rbind(matrix("pi.a",nn,1), matrix("pi.b",nn,1))
  ##V0 <- 100*diag(mm*nn)
  ##x0 <- rbind(matrix(0,nn,1), matrix(1,nn,1))
  ##V0 <- matrix(list(0),mm*nn,mm*nn)
  ##diag(V0[aa,aa]) <- "var.a"
  ##diag(V0[bb,bb]) <- "var.b"
  
  ## starting values for regr parameters
  ini_list <- list(x0=matrix(1, mm*nn, 1))
  
  ## list of model matrices & vectors
  mod_list <- list(B=BB, U=UU, Q=QQ, Z=ZZ, A=AA, R=RR)
  ##mod_list <- list(B=BB, U=UU, Q=QQ, Z=ZZ, A=AA, R=RR, x0=x0, V0=V0)
  
  ## list of control values
  con_list <- list(safe=TRUE, allow.degen=FALSE,
                   conv.test.slope.tol=2, abstol=1e-04, maxit=5e04)
  
  ## fit multivariate DLM
  mod_res[[i]] <- MARSS(assets_mpg, inits=ini_list, model=mod_list, control=con_list)
  
  ## get list of Kalman filter output
  kf_out = MARSSkfss(mod_res[[i]])
  
  ## ts of forecasted betas
  betas4 <- cbind(betas4,t(kf_out$xtt1[(1:nn)+nn,]))
  
  ## ts of SE of betas; nxT matrix
  betas4_se <- cbind(betas4_se,sqrt(t(apply(kf_out$Vtt1,3,diag)[(1:nn)+nn,])))
  
  ## ts of alphas
  alphas <- cbind(alphas,t(mod_res[[i]]$states[1:nn,]))
  ## ts of SE{alphas}
  alphas_se <- cbind(alphas_se,t(mod_res[[i]]$states.se[1:nn,]))
  
  ## ts of betas
  betas <- cbind(betas,t(mod_res[[i]]$states[(1:nn)+nn,]))
  ## ts of SE{betas}
  betas_se <- cbind(betas_se,t(mod_res[[i]]$states.se[(1:nn)+nn,]))
  
}

## assign names
colnames(alphas) <- colnames(alphas_se) <- names_pop
colnames(betas) <- colnames(betas_se) <- names_pop
colnames(betas4) <- colnames(betas4_se) <- names_pop
```

### Plots of results

```{r plot_betas_v1_2, fig.height=5, fig.width=9}
betas <- betas[,names_mat$ID]

# total num of ts
NN <- dim(betas)[2]

# set up colors; group by MPG
col.pal <- c(rainbow(6, start=0.05, end=0.12),
			 rainbow(3, start=0.2, end=0.45, v=0.7),
			 rainbow(6, start=0.8, end=0.95, v=0.85),
			 rainbow(6, start=0.55, end=0.7))

# num of rows for plot
nr <- 3
# num of cols for plot
nc <- 7

# set graphics params
par(mfcol=c(nr,nc), mai=c(0.1,0.07,0.2,0.07), omi=c(0.6,0.6,0,0))

# get extent of y-limits
yext <- c(floor(min(betas-2*betas_se, na.rm=T)/0.5)*0.5,
          ceiling(max(betas+2*betas_se, na.rm=T)/0.5)*0.5)
yext <- c(floor(min(betas-2*betas_se, na.rm=T)/0.1)*0.1,
          ceiling(max(betas+2*betas_se, na.rm=T)/0.1)*0.1)

# draw plots
for(i in 1:NN) {
	plot(t_index, betas[,i], type="n",
		 ylim=yext, xaxt="n", yaxt="n",
		 xlab="", ylab="", main=names_mat[i,"long"])
	rect(par()$usr[1], -1, par()$usr[2], 1, col=gray(0.9), border=gray(0.9))
	abline(h=0, lty="dashed")
	box()
	lines(t_index, betas[,i], col=col.pal[i], lwd=2.2)
	lines(t_index, betas[,i]+2*betas_se[,i], col=col.pal[i], lwd=0.7)
	lines(t_index, betas[,i]-2*betas_se[,i], col=col.pal[i], lwd=0.7)
	#text(xin, yin, names.pop[i], adj=c(0,1))	
	if(i<=nr | nc==1) {
#		axis(side=2, at=seq(ceiling(yext[1]/2)*2,floor(yext[2]/2)*2), las=1)
#		axis(side=2, at=seq(yext[1],yext[2])[(seq(yext[1],yext[2])%%1)==0])
		axis(side=2, las=1, tick=TRUE)
		}
	if(i%%nr==0) {
		axis(side=1, at=t_index[(t_index %% 10)==0])
		}
	}
#mtext("Brood year", side=1, outer=TRUE, line=3, cex=1.2)
mtext("Year", side=1, outer=TRUE, line=3, cex=1.2)
mtext(expression(beta[italic(t)]), side=2, outer=TRUE, line=2.2, cex=1.5)
```

## v2: a unconstrained; b unconstrained

```{r CAPM_v2, cache=TRUE}
## empty list for model results
mod_res <- vector("list", length(mpg_ID))
## empty beta forecasts
betas4 <- betas4_se <- NULL
## empty alphas & betas
alphas <- alphas_se <- betas <- betas_se <- NULL

## number of regr params = level + slope
mm <- 2

## CAPMs for each MPG
for(i in 1:length(mpg_ID)) {
  
  ## print loop ID
  print(paste0("i = ",i,"; MPG = ",mpg_ID[i]))
  ## get popns
  assets_mpg <- assets[grep(mpg_ID[i], rownames(assets)),]
  ## number of assets
  nn <- dim(assets_mpg)[1]
  
  ## Process eqn
  ## B is Identity
  BB <- "identity"
  ## U is col vec of 0's
  UU <- "zero"
  ## Q will be block diagonal
  QQ <- matrix(list(0),mm*nn,mm*nn)
  ## upper L block for alpha
  aa <- 1:nn
  ## equal var-cov
  # QQ[aa,aa] <- "alpha.cov"
  # diag(QQ[aa,aa]) <- "alpha.var"
  ## diagonal & unequal
  diag(QQ[aa,aa]) <- paste0("alpha",seq(nn))
  for(j in 1:(nn-1)) {
    for(k in (j+1):nn) {
      QQ[j,k] <- paste0("alpha",j,k)
      QQ[k,j] <- paste0("alpha",j,k)
    }
  }
  ## lower R block for beta
  bb <- aa + nn
  ## equal var-cov
  # QQ[bb,bb] <- "beta.cov"
  # diag(QQ[bb,bb]) <- "beta.var"
  ## diagonal & unequal
  diag(QQ[bb,bb]) <- paste0("beta",seq(nn))
  for(j in 1:(nn-1)) {
    for(k in (j+1):nn) {
      QQ[j+nn,k+nn] <- paste0("beta",j,k)
      QQ[k+nn,j+nn] <- paste0("beta",j,k)
    }
  }
  
  ## Observation eqn
  ## Z is array of regr variables (ie, 1's and market returns)
  ZZ <- array(NA, c(nn,mm*nn,TT))
  for(t in 1:TT) {
    ZZ[,,t] <- cbind(1,market[t]) %x% diag(nn)
  }
  ## A is col vec of 0's
  AA <- "zero"
  ## assume same obs var & cov
  ##RR <- matrix(list(0),nn,nn)
  ##RR[aa,aa] <- "obs.cov"
  ##diag(RR[aa,aa]) <- "obs.var"
  RR <- "diagonal and equal"
  
  ## starting values for regr parameters
  ini_list <- list(x0=matrix(1, mm*nn, 1))
  
  ## list of model matrices & vectors
  mod_list <- list(B=BB, U=UU, Q=QQ, Z=ZZ, A=AA, R=RR)
  ##mod_list <- list(B=BB, U=UU, Q=QQ, Z=ZZ, A=AA, R=RR, x0=x0, V0=V0)
  
  ## list of control values
  con_list <- list(safe=TRUE, allow.degen=FALSE,
                   conv.test.slope.tol=2, abstol=1e-04, maxit=5e04)
  
  ## fit multivariate DLM
  mod_res[[i]] <- MARSS(assets_mpg, inits=ini_list, model=mod_list, control=con_list)
  
  ## get list of Kalman filter output
  kf_out = MARSSkfss(mod_res[[i]])
  
  ## ts of forecasted betas
  betas4 <- cbind(betas4,t(kf_out$xtt1[(1:nn)+nn,]))
  
  ## ts of SE of betas; nxT matrix
  betas4_se <- cbind(betas4_se,sqrt(t(apply(kf_out$Vtt1,3,diag)[(1:nn)+nn,])))
  
  ## ts of alphas
  alphas <- cbind(alphas,t(mod_res[[i]]$states[1:nn,]))
  ## ts of SE{alphas}
  alphas_se <- cbind(alphas_se,t(mod_res[[i]]$states.se[1:nn,]))
  
  ## ts of betas
  betas <- cbind(betas,t(mod_res[[i]]$states[(1:nn)+nn,]))
  ## ts of SE{betas}
  betas_se <- cbind(betas_se,t(mod_res[[i]]$states.se[(1:nn)+nn,]))
  
}

## assign names
colnames(alphas) <- colnames(alphas_se) <- names_pop
colnames(betas) <- colnames(betas_se) <- names_pop
colnames(betas4) <- colnames(betas4_se) <- names_pop
```

### Plots of results

```{r plot_betas_v2_1, fig.height=5, fig.width=9}
betas <- betas[,names_mat$ID]

# total num of ts
NN <- dim(betas)[2]

# set up colors; group by MPG
col.pal <- c(rainbow(6, start=0.05, end=0.12),
			 rainbow(3, start=0.2, end=0.45, v=0.7),
			 rainbow(6, start=0.8, end=0.95, v=0.85),
			 rainbow(6, start=0.55, end=0.7))

# num of rows for plot
nr <- 3
# num of cols for plot
nc <- 7

# set graphics params
par(mfcol=c(nr,nc), mai=c(0.1,0.07,0.2,0.07), omi=c(0.6,0.6,0,0))

# get extent of y-limits
yext <- c(floor(min(betas-2*betas_se, na.rm=T)/0.5)*0.5,
          ceiling(max(betas+2*betas_se, na.rm=T)/0.5)*0.5)
yext <- c(floor(min(betas-2*betas_se, na.rm=T)/0.1)*0.1,
          ceiling(max(betas+2*betas_se, na.rm=T)/0.1)*0.1)

# draw plots
for(i in 1:NN) {
	plot(t_index, betas[,i], type="n",
		 ylim=yext, xaxt="n", yaxt="n",
		 xlab="", ylab="", main=names_mat[i,"long"])
	rect(par()$usr[1], -1, par()$usr[2], 1, col=gray(0.9), border=gray(0.9))
	abline(h=0, lty="dashed")
	box()
	lines(t_index, betas[,i], col=col.pal[i], lwd=2.2)
	lines(t_index, betas[,i]+2*betas_se[,i], col=col.pal[i], lwd=0.7)
	lines(t_index, betas[,i]-2*betas_se[,i], col=col.pal[i], lwd=0.7)
	#text(xin, yin, names.pop[i], adj=c(0,1))	
	if(i<=nr | nc==1) {
#		axis(side=2, at=seq(ceiling(yext[1]/2)*2,floor(yext[2]/2)*2), las=1)
#		axis(side=2, at=seq(yext[1],yext[2])[(seq(yext[1],yext[2])%%1)==0])
		axis(side=2, las=1, tick=TRUE)
		}
	if(i%%nr==0) {
		axis(side=1, at=t_index[(t_index %% 10)==0])
		}
	}
#mtext("Brood year", side=1, outer=TRUE, line=3, cex=1.2)
mtext("Year", side=1, outer=TRUE, line=3, cex=1.2)
mtext(expression(beta[italic(t)]), side=2, outer=TRUE, line=2.2, cex=1.5)
```

## v2: a unconstrained; b equalvarcov

```{r CAPM_v2_2, cache=TRUE}
## empty list for model results
mod_res <- vector("list", length(mpg_ID))
## empty beta forecasts
betas4 <- betas4_se <- NULL
## empty alphas & betas
alphas <- alphas_se <- betas <- betas_se <- NULL

## number of regr params = level + slope
mm <- 2

## CAPMs for each MPG
for(i in 1:length(mpg_ID)) {
  
  ## print loop ID
  print(paste0("i = ",i,"; MPG = ",mpg_ID[i]))
  ## get popns
  assets_mpg <- assets[grep(mpg_ID[i], rownames(assets)),]
  ## number of assets
  nn <- dim(assets_mpg)[1]
  
  ## Process eqn
  ## B is Identity
  BB <- "identity"
  ## U is col vec of 0's
  UU <- "zero"
  ## Q will be block diagonal
  QQ <- matrix(list(0),mm*nn,mm*nn)
  ## upper L block for alpha
  aa <- 1:nn
  ## equal var-cov
  # QQ[aa,aa] <- "alpha.cov"
  # diag(QQ[aa,aa]) <- "alpha.var"
  ## diagonal & unequal
  diag(QQ[aa,aa]) <- paste0("alpha",seq(nn))
  for(j in 1:(nn-1)) {
    for(k in (j+1):nn) {
      QQ[j,k] <- paste0("alpha",j,k)
      QQ[k,j] <- paste0("alpha",j,k)
    }
  }
  ## lower R block for beta
  bb <- aa + nn
  ## equal var-cov
  QQ[bb,bb] <- "beta.cov"
  diag(QQ[bb,bb]) <- "beta.var"
  ## diagonal & unequal
  # diag(QQ[bb,bb]) <- paste0("beta",seq(nn))
  # for(j in 1:(nn-1)) {
  #   for(k in (j+1):nn) {
  #     QQ[j+nn,k+nn] <- paste0("beta",j,k)
  #     QQ[k+nn,j+nn] <- paste0("beta",j,k)
  #   }
  # }
  
  ## Observation eqn
  ## Z is array of regr variables (ie, 1's and market returns)
  ZZ <- array(NA, c(nn,mm*nn,TT))
  for(t in 1:TT) {
    ZZ[,,t] <- cbind(1,market[t]) %x% diag(nn)
  }
  ## A is col vec of 0's
  AA <- "zero"
  ## assume same obs var & cov
  ##RR <- matrix(list(0),nn,nn)
  ##RR[aa,aa] <- "obs.cov"
  ##diag(RR[aa,aa]) <- "obs.var"
  RR <- "diagonal and equal"
  
  ## starting values for regr parameters
  ini_list <- list(x0=matrix(1, mm*nn, 1))
  
  ## list of model matrices & vectors
  mod_list <- list(B=BB, U=UU, Q=QQ, Z=ZZ, A=AA, R=RR)
  ##mod_list <- list(B=BB, U=UU, Q=QQ, Z=ZZ, A=AA, R=RR, x0=x0, V0=V0)
  
  ## list of control values
  con_list <- list(safe=TRUE, allow.degen=FALSE,
                   conv.test.slope.tol=2, abstol=1e-04, maxit=5e04)
  
  ## fit multivariate DLM
  mod_res[[i]] <- MARSS(assets_mpg, inits=ini_list, model=mod_list, control=con_list)
  
  ## get list of Kalman filter output
  kf_out = MARSSkfss(mod_res[[i]])
  
  ## ts of forecasted betas
  betas4 <- cbind(betas4,t(kf_out$xtt1[(1:nn)+nn,]))
  
  ## ts of SE of betas; nxT matrix
  betas4_se <- cbind(betas4_se,sqrt(t(apply(kf_out$Vtt1,3,diag)[(1:nn)+nn,])))
  
  ## ts of alphas
  alphas <- cbind(alphas,t(mod_res[[i]]$states[1:nn,]))
  ## ts of SE{alphas}
  alphas_se <- cbind(alphas_se,t(mod_res[[i]]$states.se[1:nn,]))
  
  ## ts of betas
  betas <- cbind(betas,t(mod_res[[i]]$states[(1:nn)+nn,]))
  ## ts of SE{betas}
  betas_se <- cbind(betas_se,t(mod_res[[i]]$states.se[(1:nn)+nn,]))
  
}

## assign names
colnames(alphas) <- colnames(alphas_se) <- names_pop
colnames(betas) <- colnames(betas_se) <- names_pop
colnames(betas4) <- colnames(betas4_se) <- names_pop
```

### Plots of results

```{r plot_betas_v2_2, fig.height=5, fig.width=9}
betas <- betas[,names_mat$ID]

# total num of ts
NN <- dim(betas)[2]

# set up colors; group by MPG
col.pal <- c(rainbow(6, start=0.05, end=0.12),
             rainbow(3, start=0.2, end=0.45, v=0.7),
             rainbow(6, start=0.8, end=0.95, v=0.85),
             rainbow(6, start=0.55, end=0.7))

# num of rows for plot
nr <- 3
# num of cols for plot
nc <- 7

# set graphics params
par(mfcol=c(nr,nc), mai=c(0.1,0.07,0.2,0.07), omi=c(0.6,0.6,0,0))

# get extent of y-limits
yext <- c(floor(min(betas-2*betas_se, na.rm=T)/0.5)*0.5,
          ceiling(max(betas+2*betas_se, na.rm=T)/0.5)*0.5)
yext <- c(floor(min(betas-2*betas_se, na.rm=T)/0.1)*0.1,
          ceiling(max(betas+2*betas_se, na.rm=T)/0.1)*0.1)

# draw plots
for(i in 1:NN) {
	plot(t_index, betas[,i], type="n",
		 ylim=yext, xaxt="n", yaxt="n",
		 xlab="", ylab="", main=names_mat[i,"long"])
	rect(par()$usr[1], -1, par()$usr[2], 1, col=gray(0.9), border=gray(0.9))
	abline(h=0, lty="dashed")
	box()
	lines(t_index, betas[,i], col=col.pal[i], lwd=2.2)
	lines(t_index, betas[,i]+2*betas_se[,i], col=col.pal[i], lwd=0.7)
	lines(t_index, betas[,i]-2*betas_se[,i], col=col.pal[i], lwd=0.7)
	#text(xin, yin, names.pop[i], adj=c(0,1))	
	if(i<=nr | nc==1) {
#		axis(side=2, at=seq(ceiling(yext[1]/2)*2,floor(yext[2]/2)*2), las=1)
#		axis(side=2, at=seq(yext[1],yext[2])[(seq(yext[1],yext[2])%%1)==0])
		axis(side=2, las=1, tick=TRUE)
		}
	if(i%%nr==0) {
		axis(side=1, at=t_index[(t_index %% 10)==0])
		}
	}
#mtext("Brood year", side=1, outer=TRUE, line=3, cex=1.2)
mtext("Year", side=1, outer=TRUE, line=3, cex=1.2)
mtext(expression(beta[italic(t)]), side=2, outer=TRUE, line=2.2, cex=1.5)
```

## v3: a equalvarcov; b unconstrained

```{r CAPM_v3_1, cache=TRUE}
## empty list for model results
mod_res <- vector("list", length(mpg_ID))
## empty beta forecasts
betas4 <- betas4_se <- NULL
## empty alphas & betas
alphas <- alphas_se <- betas <- betas_se <- NULL

## number of regr params = level + slope
mm <- 2

## CAPMs for each MPG
for(i in 1:length(mpg_ID)) {
  
  ## print loop ID
  print(paste0("i = ",i,"; MPG = ",mpg_ID[i]))
  ## get popns
  assets_mpg <- assets[grep(mpg_ID[i], rownames(assets)),]
  ## number of assets
  nn <- dim(assets_mpg)[1]
  
  ## Process eqn
  ## B is Identity
  BB <- "identity"
  ## U is col vec of 0's
  UU <- "zero"
  ## Q will be block diagonal
  QQ <- matrix(list(0),mm*nn,mm*nn)
  ## upper L block for alpha
  aa <- 1:nn
  ## equal var-cov
  QQ[aa,aa] <- "alpha.cov"
  diag(QQ[aa,aa]) <- "alpha.var"
  ## lower R block for beta
  bb <- aa + nn
  ## diagonal & unequal
  diag(QQ[bb,bb]) <- paste0("beta",seq(nn))
  for(j in 1:(nn-1)) {
    for(k in (j+1):nn) {
      QQ[j+nn,k+nn] <- paste0("beta",j,k)
      QQ[k+nn,j+nn] <- paste0("beta",j,k)
    }
  }
  
  ## Observation eqn
  ## Z is array of regr variables (ie, 1's and market returns)
  ZZ <- array(NA, c(nn,mm*nn,TT))
  for(t in 1:TT) {
    ZZ[,,t] <- cbind(1,market[t]) %x% diag(nn)
  }
  ## A is col vec of 0's
  AA <- "zero"
  ## assume same obs var & cov
  ##RR <- matrix(list(0),nn,nn)
  ##RR[aa,aa] <- "obs.cov"
  ##diag(RR[aa,aa]) <- "obs.var"
  RR <- "diagonal and equal"
  
  ## starting values for regr parameters
  ini_list <- list(x0=matrix(1, mm*nn, 1))
  
  ## list of model matrices & vectors
  mod_list <- list(B=BB, U=UU, Q=QQ, Z=ZZ, A=AA, R=RR)
  ##mod_list <- list(B=BB, U=UU, Q=QQ, Z=ZZ, A=AA, R=RR, x0=x0, V0=V0)
  
  ## list of control values
  con_list <- list(safe=TRUE, allow.degen=FALSE,
                   conv.test.slope.tol=2, abstol=1e-04, maxit=5e04)
  
  ## fit multivariate DLM
  mod_res[[i]] <- MARSS(assets_mpg, inits=ini_list, model=mod_list, control=con_list)
  
  ## get list of Kalman filter output
  kf_out = MARSSkfss(mod_res[[i]])
  
  ## ts of forecasted betas
  betas4 <- cbind(betas4,t(kf_out$xtt1[(1:nn)+nn,]))
  
  ## ts of SE of betas; nxT matrix
  betas4_se <- cbind(betas4_se,sqrt(t(apply(kf_out$Vtt1,3,diag)[(1:nn)+nn,])))
  
  ## ts of alphas
  alphas <- cbind(alphas,t(mod_res[[i]]$states[1:nn,]))
  ## ts of SE{alphas}
  alphas_se <- cbind(alphas_se,t(mod_res[[i]]$states.se[1:nn,]))
  
  ## ts of betas
  betas <- cbind(betas,t(mod_res[[i]]$states[(1:nn)+nn,]))
  ## ts of SE{betas}
  betas_se <- cbind(betas_se,t(mod_res[[i]]$states.se[(1:nn)+nn,]))
  
}

## assign names
colnames(alphas) <- colnames(alphas_se) <- names_pop
colnames(betas) <- colnames(betas_se) <- names_pop
colnames(betas4) <- colnames(betas4_se) <- names_pop
```

### Plots of results

```{r plot_betas_v3_1, fig.height=5, fig.width=9}
betas <- betas[,names_mat$ID]

# total num of ts
NN <- dim(betas)[2]

# set up colors; group by MPG
col.pal <- c(rainbow(6, start=0.05, end=0.12),
			 rainbow(3, start=0.2, end=0.45, v=0.7),
			 rainbow(6, start=0.8, end=0.95, v=0.85),
			 rainbow(6, start=0.55, end=0.7))

# num of rows for plot
nr <- 3
# num of cols for plot
nc <- 7

# set graphics params
par(mfcol=c(nr,nc), mai=c(0.1,0.07,0.2,0.07), omi=c(0.6,0.6,0,0))

# get extent of y-limits
yext <- c(floor(min(betas-2*betas_se, na.rm=T)/0.5)*0.5,
          ceiling(max(betas+2*betas_se, na.rm=T)/0.5)*0.5)
yext <- c(floor(min(betas-2*betas_se, na.rm=T)/0.1)*0.1,
          ceiling(max(betas+2*betas_se, na.rm=T)/0.1)*0.1)

# draw plots
for(i in 1:NN) {
	plot(t_index, betas[,i], type="n",
		 ylim=yext, xaxt="n", yaxt="n",
		 xlab="", ylab="", main=names_mat[i,"long"])
	rect(par()$usr[1], -1, par()$usr[2], 1, col=gray(0.9), border=gray(0.9))
	abline(h=0, lty="dashed")
	box()
	lines(t_index, betas[,i], col=col.pal[i], lwd=2.2)
	lines(t_index, betas[,i]+2*betas_se[,i], col=col.pal[i], lwd=0.7)
	lines(t_index, betas[,i]-2*betas_se[,i], col=col.pal[i], lwd=0.7)
	#text(xin, yin, names.pop[i], adj=c(0,1))	
	if(i<=nr | nc==1) {
#		axis(side=2, at=seq(ceiling(yext[1]/2)*2,floor(yext[2]/2)*2), las=1)
#		axis(side=2, at=seq(yext[1],yext[2])[(seq(yext[1],yext[2])%%1)==0])
		axis(side=2, las=1, tick=TRUE)
		}
	if(i%%nr==0) {
		axis(side=1, at=t_index[(t_index %% 10)==0])
		}
	}
#mtext("Brood year", side=1, outer=TRUE, line=3, cex=1.2)
mtext("Year", side=1, outer=TRUE, line=3, cex=1.2)
mtext(expression(beta[italic(t)]), side=2, outer=TRUE, line=2.2, cex=1.5)
```

## v3: a equalvarcov; b equalvarcov

```{r CAPM_v3_2, cache=TRUE}
## empty list for model results
mod_res <- vector("list", length(mpg_ID))
## empty beta forecasts
betas4 <- betas4_se <- NULL
## empty alphas & betas
alphas <- alphas_se <- betas <- betas_se <- NULL

## number of regr params = level + slope
mm <- 2

## CAPMs for each MPG
for(i in 1:length(mpg_ID)) {
  
  ## print loop ID
  print(paste0("i = ",i,"; MPG = ",mpg_ID[i]))
  ## get popns
  assets_mpg <- assets[grep(mpg_ID[i], rownames(assets)),]
  ## number of assets
  nn <- dim(assets_mpg)[1]
  
  ## Process eqn
  ## B is Identity
  BB <- "identity"
  ## U is col vec of 0's
  UU <- "zero"
  ## Q will be block diagonal
  QQ <- matrix(list(0),mm*nn,mm*nn)
  ## upper L block for alpha
  aa <- 1:nn
  ## equal var-cov
  QQ[aa,aa] <- "alpha.cov"
  diag(QQ[aa,aa]) <- "alpha.var"
  ## lower R block for beta
  bb <- aa + nn
  ## equal var-cov
  QQ[bb,bb] <- "beta.cov"
  diag(QQ[bb,bb]) <- "beta.var"

  ## Observation eqn
  ## Z is array of regr variables (ie, 1's and market returns)
  ZZ <- array(NA, c(nn,mm*nn,TT))
  for(t in 1:TT) {
    ZZ[,,t] <- cbind(1,market[t]) %x% diag(nn)
  }
  ## A is col vec of 0's
  AA <- "zero"
  ## assume same obs var & cov
  ##RR <- matrix(list(0),nn,nn)
  ##RR[aa,aa] <- "obs.cov"
  ##diag(RR[aa,aa]) <- "obs.var"
  RR <- "diagonal and equal"
  
  ## starting values for regr parameters
  ini_list <- list(x0=matrix(1, mm*nn, 1))
  
  ## list of model matrices & vectors
  mod_list <- list(B=BB, U=UU, Q=QQ, Z=ZZ, A=AA, R=RR)
  ##mod_list <- list(B=BB, U=UU, Q=QQ, Z=ZZ, A=AA, R=RR, x0=x0, V0=V0)
  
  ## list of control values
  con_list <- list(safe=TRUE, allow.degen=FALSE,
                   conv.test.slope.tol=2, abstol=1e-04, maxit=5e04)
  
  ## fit multivariate DLM
  mod_res[[i]] <- MARSS(assets_mpg, inits=ini_list, model=mod_list, control=con_list)
  
  ## get list of Kalman filter output
  kf_out = MARSSkfss(mod_res[[i]])
  
  ## ts of forecasted betas
  betas4 <- cbind(betas4,t(kf_out$xtt1[(1:nn)+nn,]))
  
  ## ts of SE of betas; nxT matrix
  betas4_se <- cbind(betas4_se,sqrt(t(apply(kf_out$Vtt1,3,diag)[(1:nn)+nn,])))
  
  ## ts of alphas
  alphas <- cbind(alphas,t(mod_res[[i]]$states[1:nn,]))
  ## ts of SE{alphas}
  alphas_se <- cbind(alphas_se,t(mod_res[[i]]$states.se[1:nn,]))
  
  ## ts of betas
  betas <- cbind(betas,t(mod_res[[i]]$states[(1:nn)+nn,]))
  ## ts of SE{betas}
  betas_se <- cbind(betas_se,t(mod_res[[i]]$states.se[(1:nn)+nn,]))
  
}

## assign names
colnames(alphas) <- colnames(alphas_se) <- names_pop
colnames(betas) <- colnames(betas_se) <- names_pop
colnames(betas4) <- colnames(betas4_se) <- names_pop
```

### Plots of results

```{r plot_betas_v3_2, fig.height=5, fig.width=9}
betas <- betas[,names_mat$ID]

# total num of ts
NN <- dim(betas)[2]

# set up colors; group by MPG
col.pal <- c(rainbow(6, start=0.05, end=0.12),
             rainbow(3, start=0.2, end=0.45, v=0.7),
             rainbow(6, start=0.8, end=0.95, v=0.85),
             rainbow(6, start=0.55, end=0.7))

# num of rows for plot
nr <- 3
# num of cols for plot
nc <- 7

# set graphics params
par(mfcol=c(nr,nc), mai=c(0.1,0.07,0.2,0.07), omi=c(0.6,0.6,0,0))

# get extent of y-limits
yext <- c(floor(min(betas-2*betas_se, na.rm=T)/0.5)*0.5,
          ceiling(max(betas+2*betas_se, na.rm=T)/0.5)*0.5)
yext <- c(floor(min(betas-2*betas_se, na.rm=T)/0.1)*0.1,
          ceiling(max(betas+2*betas_se, na.rm=T)/0.1)*0.1)

# draw plots
for(i in 1:NN) {
	plot(t_index, betas[,i], type="n",
		 ylim=yext, xaxt="n", yaxt="n",
		 xlab="", ylab="", main=names_mat[i,"long"])
	rect(par()$usr[1], -1, par()$usr[2], 1, col=gray(0.9), border=gray(0.9))
	abline(h=0, lty="dashed")
	box()
	lines(t_index, betas[,i], col=col.pal[i], lwd=2.2)
	lines(t_index, betas[,i]+2*betas_se[,i], col=col.pal[i], lwd=0.7)
	lines(t_index, betas[,i]-2*betas_se[,i], col=col.pal[i], lwd=0.7)
	#text(xin, yin, names.pop[i], adj=c(0,1))	
	if(i<=nr | nc==1) {
#		axis(side=2, at=seq(ceiling(yext[1]/2)*2,floor(yext[2]/2)*2), las=1)
#		axis(side=2, at=seq(yext[1],yext[2])[(seq(yext[1],yext[2])%%1)==0])
		axis(side=2, las=1, tick=TRUE)
		}
	if(i%%nr==0) {
		axis(side=1, at=t_index[(t_index %% 10)==0])
		}
	}
#mtext("Brood year", side=1, outer=TRUE, line=3, cex=1.2)
mtext("Year", side=1, outer=TRUE, line=3, cex=1.2)
mtext(expression(beta[italic(t)]), side=2, outer=TRUE, line=2.2, cex=1.5)
```

## v4: fully unconstrained

```{r CAPM_v4, cache=TRUE, eval=FALSE}
## empty list for model results
mod_res <- vector("list", length(mpg_ID))
## empty beta forecasts
betas4 <- betas4_se <- NULL
## empty alphas & betas
alphas <- alphas_se <- betas <- betas_se <- NULL

## number of regr params = level + slope
mm <- 2

## CAPMs for each MPG
for(i in 1:length(mpg_ID)) {
  
  ## print loop ID
  print(paste0("i = ",i,"; MPG = ",mpg_ID[i]))
  ## get popns
  assets_mpg <- assets[grep(mpg_ID[i], rownames(assets)),]
  ## number of assets
  nn <- dim(assets_mpg)[1]
  
  ## Process eqn
  ## B is Identity
  BB <- "identity"
  ## U is col vec of 0's
  UU <- "zero"
  ## Q will be block diagonal
  QQ <- "unconstrained"

  ## Observation eqn
  ## Z is array of regr variables (ie, 1's and market returns)
  ZZ <- array(NA, c(nn,mm*nn,TT))
  for(t in 1:TT) {
    ZZ[,,t] <- cbind(1,market[t]) %x% diag(nn)
  }
  ## A is col vec of 0's
  AA <- "zero"
  ## assume same obs var & cov
  ##RR <- matrix(list(0),nn,nn)
  ##RR[aa,aa] <- "obs.cov"
  ##diag(RR[aa,aa]) <- "obs.var"
  RR <- "diagonal and equal"
  
  ## Initial states
  ##x0 <- rbind(matrix("pi.a",nn,1), matrix("pi.b",nn,1))
  ##V0 <- 100*diag(mm*nn)
  ##x0 <- rbind(matrix(0,nn,1), matrix(1,nn,1))
  ##V0 <- matrix(list(0),mm*nn,mm*nn)
  ##diag(V0[aa,aa]) <- "var.a"
  ##diag(V0[bb,bb]) <- "var.b"
  
  ## starting values for regr parameters
  ini_list <- list(x0=matrix(1, mm*nn, 1))
  
  ## list of model matrices & vectors
  mod_list <- list(B=BB, U=UU, Q=QQ, Z=ZZ, A=AA, R=RR)
  ##mod_list <- list(B=BB, U=UU, Q=QQ, Z=ZZ, A=AA, R=RR, x0=x0, V0=V0)
  
  ## list of control values
  con_list <- list(safe=TRUE, allow.degen=FALSE,
                   conv.test.slope.tol=2, abstol=1e-04, maxit=5e04)
  
  ## fit multivariate DLM
  mod_res[[i]] <- MARSS(assets_mpg, inits=ini_list, model=mod_list, control=con_list)
  
  ## get list of Kalman filter output
  kf_out = MARSSkfss(mod_res[[i]])
  
  ## ts of forecasted betas
  betas4 <- cbind(betas4,t(kf_out$xtt1[(1:nn)+nn,]))
  
  ## ts of SE of betas; nxT matrix
  betas4_se <- cbind(betas4_se,sqrt(t(apply(kf_out$Vtt1,3,diag)[(1:nn)+nn,])))
  
  ## ts of alphas
  alphas <- cbind(alphas,t(mod_res[[i]]$states[1:nn,]))
  ## ts of SE{alphas}
  alphas_se <- cbind(alphas_se,t(mod_res[[i]]$states.se[1:nn,]))
  
  ## ts of betas
  betas <- cbind(betas,t(mod_res[[i]]$states[(1:nn)+nn,]))
  ## ts of SE{betas}
  betas_se <- cbind(betas_se,t(mod_res[[i]]$states.se[(1:nn)+nn,]))
  
}

## assign names
colnames(alphas) <- colnames(alphas_se) <- names_pop
colnames(betas) <- colnames(betas_se) <- names_pop
colnames(betas4) <- colnames(betas4_se) <- names_pop
```

### Plots of results

```{r plot_betas_v4_1, fig.height=5, fig.width=9, eval=FALSE}
betas <- betas[,names_mat$ID]

# total num of ts
NN <- dim(betas)[2]

# set up colors; group by MPG
col.pal <- c(rainbow(6, start=0.05, end=0.12),
			 rainbow(3, start=0.2, end=0.45, v=0.7),
			 rainbow(6, start=0.8, end=0.95, v=0.85),
			 rainbow(6, start=0.55, end=0.7))

# num of rows for plot
nr <- 3
# num of cols for plot
nc <- 7

# set graphics params
par(mfcol=c(nr,nc), mai=c(0.1,0.07,0.2,0.07), omi=c(0.6,0.6,0,0))

# get extent of y-limits
yext <- c(floor(min(betas-2*betas_se, na.rm=T)/0.5)*0.5,
          ceiling(max(betas+2*betas_se, na.rm=T)/0.5)*0.5)
yext <- c(floor(min(betas-2*betas_se, na.rm=T)/0.1)*0.1,
          ceiling(max(betas+2*betas_se, na.rm=T)/0.1)*0.1)

# draw plots
for(i in 1:NN) {
	plot(t_index, betas[,i], type="n",
		 ylim=yext, xaxt="n", yaxt="n",
		 xlab="", ylab="", main=names_mat[i,"long"])
	rect(par()$usr[1], -1, par()$usr[2], 1, col=gray(0.9), border=gray(0.9))
	abline(h=0, lty="dashed")
	box()
	lines(t_index, betas[,i], col=col.pal[i], lwd=2.2)
	lines(t_index, betas[,i]+2*betas_se[,i], col=col.pal[i], lwd=0.7)
	lines(t_index, betas[,i]-2*betas_se[,i], col=col.pal[i], lwd=0.7)
	#text(xin, yin, names.pop[i], adj=c(0,1))	
	if(i<=nr | nc==1) {
#		axis(side=2, at=seq(ceiling(yext[1]/2)*2,floor(yext[2]/2)*2), las=1)
#		axis(side=2, at=seq(yext[1],yext[2])[(seq(yext[1],yext[2])%%1)==0])
		axis(side=2, las=1, tick=TRUE)
		}
	if(i%%nr==0) {
		axis(side=1, at=t_index[(t_index %% 10)==0])
		}
	}
#mtext("Brood year", side=1, outer=TRUE, line=3, cex=1.2)
mtext("Year", side=1, outer=TRUE, line=3, cex=1.2)
mtext(expression(beta[italic(t)]), side=2, outer=TRUE, line=2.2, cex=1.5)
```

